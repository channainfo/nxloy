# Database Migrations Guide - NxLoy Platform

**Author**: Ploy Lab (NxLoy Platform)
**Last Updated**: 2025-11-07
**Version**: 1.0.0

---

## Table of Contents

1. [Overview](#overview)
2. [Prisma Migrate vs Rails Migrations](#prisma-migrate-vs-rails-migrations)
3. [Multi-File Schema Migrations](#multi-file-schema-migrations)
4. [Development Workflow](#development-workflow)
5. [Multi-Agent Collaboration](#multi-agent-collaboration)
6. [Common Migration Patterns](#common-migration-patterns)
7. [Zero-Downtime Migrations](#zero-downtime-migrations)
8. [Multi-Tenant Patterns](#multi-tenant-patterns)
9. [Soft Delete Patterns](#soft-delete-patterns)
10. [Data Migrations](#data-migrations)
11. [Rollback Strategies](#rollback-strategies)
12. [CI/CD Integration](#cicd-integration)
13. [Migration Checklist](#migration-checklist)

---

## Overview

NxLoy uses **Prisma Migrate** for database schema management. Prisma Migrate is a declarative migration tool that:

- **Schema-First**: Define schema in Prisma files, migrations are auto-generated
- **Type-Safe**: Prisma Client is regenerated with every migration
- **Version Controlled**: Migration files are stored in git
- **Atomic**: Each migration runs in a transaction (when supported by database)
- **Multi-File Support**: Schemas organized by domain (Prisma 6.7.0+)

### Key Concepts

```
Prisma Schema Files        Migration Files           Database
┌──────────────────┐      ┌──────────────────┐     ┌──────────────┐
│ base.prisma      │      │ 001_init.sql     │     │ PostgreSQL   │
│ auth.prisma      │─────>│ 002_add_user.sql │────>│ Tables       │
│ loyalty.prisma   │      │ 003_add_tier.sql │     │ Columns      │
│ ...              │      │ ...              │     │ Indexes      │
└──────────────────┘      └──────────────────┘     └──────────────┘
```

### File Locations

```
packages/database/
├── prisma/
│   ├── schema/                    # Multi-file schemas
│   │   ├── base.prisma           # Config, enums, shared types
│   │   ├── auth.prisma           # Authentication domain
│   │   ├── loyalty.prisma        # Loyalty domain
│   │   ├── rewards.prisma        # Rewards domain
│   │   ├── customer.prisma       # Customer domain
│   │   ├── partner.prisma        # Partner domain
│   │   ├── subscription.prisma   # Subscription domain
│   │   ├── referral.prisma       # Referral domain
│   │   └── blockchain.prisma     # Blockchain domain
│   └── migrations/               # Generated SQL migrations
│       ├── 20250107000001_init/
│       │   └── migration.sql
│       ├── 20250107000002_add_user_table/
│       │   └── migration.sql
│       └── migration_lock.toml
└── src/
    └── index.ts                  # Export Prisma Client
```

---

## Prisma Migrate vs Rails Migrations

### Comparison Table

| Feature | Prisma Migrate | Rails ActiveRecord |
|---------|---------------|-------------------|
| **Approach** | Schema-first (declarative) | Migration-first (imperative) |
| **Schema Definition** | Prisma schema files | Ruby migration files |
| **SQL Generation** | Auto-generated from schema diff | Manual in migration files |
| **Type Safety** | Yes (TypeScript) | Limited (Ruby dynamic) |
| **Rollback** | Manual (no auto-down) | Automatic (up/down methods) |
| **Data Migrations** | Manual (TypeScript/SQL) | Built-in (change_column, etc.) |
| **Multi-File Schema** | Yes (6.7.0+) | N/A (schema.rb is single file) |
| **Preview Before Apply** | Yes (`prisma migrate diff`) | Yes (`db:migrate:status`) |

### Example: Adding a Column

**Rails Migration**:
```ruby
# db/migrate/20250107000001_add_phone_to_users.rb
class AddPhoneToUsers < ActiveRecord::Migration[7.0]
  def change
    add_column :users, :phone, :string
    add_index :users, :phone, unique: true
  end

  def down
    remove_column :users, :phone
  end
end
```

**Prisma Migrate**:
```prisma
// packages/database/prisma/schema/auth.prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  phone     String?  @unique  // ← Add this line
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

Then run:
```bash
cd packages/database
pnpm prisma migrate dev --name add_phone_to_users
```

Prisma auto-generates:
```sql
-- packages/database/prisma/migrations/20250107000001_add_phone_to_users/migration.sql
ALTER TABLE "User" ADD COLUMN "phone" TEXT;
CREATE UNIQUE INDEX "User_phone_key" ON "User"("phone");
```

### Key Differences

1. **Schema as Source of Truth**:
   - **Prisma**: Schema files are the source of truth
   - **Rails**: Migration files are the source of truth, schema.rb is generated

2. **Migration Generation**:
   - **Prisma**: Auto-generated by diffing schema with database
   - **Rails**: Manually written by developers

3. **Rollback**:
   - **Prisma**: No automatic down migrations, manual rollback required
   - **Rails**: Automatic down migrations via `def down` or reversible blocks

4. **Data Migrations**:
   - **Prisma**: Separate TypeScript scripts or raw SQL in migration file
   - **Rails**: Built-in support via `change_column`, `update_all`, etc.

---

## Multi-File Schema Migrations

NxLoy uses Prisma's multi-file schema feature (6.7.0+) to organize models by domain.

### Schema Organization

```
prisma/schema/
├── base.prisma           # Configuration, datasource, generator, shared enums
├── auth.prisma           # User, Account, Session, Role, Permission
├── loyalty.prisma        # LoyaltyProgram, LoyaltyTier, PointTransaction
├── rewards.prisma        # Reward, RewardRedemption, RewardInventory
├── customer.prisma       # Customer, CustomerSegment, CustomerActivity
├── partner.prisma        # Partner, PartnerIntegration, PartnerRevenue
├── subscription.prisma   # SubscriptionPlan, Subscription, Invoice
├── referral.prisma       # ReferralCode, ReferralReward
└── blockchain.prisma     # NFTToken, Wallet, SmartContract
```

### How Multi-File Migrations Work

1. **Edit any schema file** (e.g., `auth.prisma`):
   ```prisma
   model User {
     id        String   @id @default(cuid())
     email     String   @unique
     firstName String   // ← Add this
     lastName  String   // ← Add this
   }
   ```

2. **Run migration command**:
   ```bash
   cd packages/database
   pnpm prisma migrate dev --name add_user_names
   ```

3. **Prisma reads ALL schema files** in `prisma/schema/` directory

4. **Generates single migration** with changes from all files:
   ```sql
   -- migration.sql
   ALTER TABLE "User" ADD COLUMN "firstName" TEXT NOT NULL;
   ALTER TABLE "User" ADD COLUMN "lastName" TEXT NOT NULL;
   ```

5. **Regenerates Prisma Client** with all models from all schema files

### Benefits of Multi-File Schema

- **Domain Isolation**: Each domain has its own file
- **Merge Conflict Reduction**: Multiple agents can edit different files
- **Easier Navigation**: Find models by domain quickly
- **Clear Ownership**: Each file maps to a bounded context
- **Better Git Diffs**: Changes are isolated to relevant domain files

---

## Development Workflow

### Daily Development Flow

```bash
# 1. Pull latest changes
git pull origin main

# 2. Apply any new migrations from teammates
cd packages/database
pnpm prisma migrate dev

# 3. Make schema changes
# Edit any schema file (e.g., auth.prisma)

# 4. Create migration
pnpm prisma migrate dev --name descriptive_name

# 5. Verify migration
cat prisma/migrations/$(ls -t prisma/migrations | head -1)/migration.sql

# 6. Test migration
pnpm prisma migrate reset  # Reset to clean state
pnpm prisma migrate dev    # Reapply all migrations

# 7. Commit schema + migration files
git add prisma/schema/ prisma/migrations/
git commit -m "feat(database): add user profile fields"
```

### Command Reference

```bash
# Development Commands
pnpm prisma migrate dev              # Create and apply migration
pnpm prisma migrate dev --name xxx   # Create with specific name
pnpm prisma migrate reset            # Reset DB + reapply all migrations
pnpm prisma migrate status           # Check migration status
pnpm prisma generate                 # Regenerate Prisma Client

# Production Commands
pnpm prisma migrate deploy           # Apply migrations in production
pnpm prisma migrate resolve --applied xxx  # Mark migration as applied
pnpm prisma migrate resolve --rolled-back xxx  # Mark migration as rolled back

# Inspection Commands
pnpm prisma migrate diff             # Preview changes
pnpm prisma db pull                  # Introspect database to schema
pnpm prisma db push                  # Push schema to DB (prototyping only)

# Studio (Database GUI)
pnpm prisma studio                   # Open Prisma Studio at http://localhost:5555
```

### Migration Naming Conventions

Use descriptive names following this pattern:

```
{action}_{entity}_{detail}

Examples:
- add_user_table
- add_email_verification
- add_index_users_email
- rename_customer_name
- drop_old_sessions
- add_businessid_to_loyalty
- add_deletedat_for_soft_delete
```

**Bad Names** (too vague):
- update
- changes
- fix
- migration
- new_fields

---

## Multi-Agent Collaboration

### Git Worktree Workflow

When multiple AI agents work in parallel using git worktrees, follow this workflow:

```
Main Repository              Agent 1 Worktree           Agent 2 Worktree
┌─────────────────┐         ┌──────────────────┐       ┌──────────────────┐
│ nxloy/main      │         │ nxloy-agent-1/   │       │ nxloy-agent-2/   │
│                 │         │ feature-auth     │       │ feature-loyalty  │
│ auth.prisma     │────────>│ auth.prisma ✏️   │       │ loyalty.prisma ✏️│
│ loyalty.prisma  │         │ (editing)        │       │ (editing)        │
│                 │         └──────────────────┘       └──────────────────┘
└─────────────────┘                 │                           │
                                    │                           │
                                    v                           v
                            Migration A               Migration B
```

### Collaboration Rules

1. **One Domain Per Agent**:
   - Agent 1: Works on `auth.prisma` only
   - Agent 2: Works on `loyalty.prisma` only
   - Reduces merge conflicts significantly

2. **Migration Independence**:
   - Each agent creates migrations independently
   - Migrations are sequential (timestamped)
   - Merge conflicts resolved at migration level, not schema level

3. **Shared Enums/Types**:
   - Only edit `base.prisma` for shared types
   - Coordinate changes to shared enums via communication
   - Example: Adding new `Status` enum value affects all domains

### Handling Migration Conflicts

**Scenario**: Two agents create migrations simultaneously

**Agent 1** (in worktree `nxloy-agent-1`):
```bash
# Creates migration at 2025-11-07 10:00:00
pnpm prisma migrate dev --name add_user_mfa
# Result: 20251107100000_add_user_mfa/
```

**Agent 2** (in worktree `nxloy-agent-2`):
```bash
# Creates migration at 2025-11-07 10:01:00
pnpm prisma migrate dev --name add_loyalty_tiers
# Result: 20251107100100_add_loyalty_tiers/
```

**When merging**:

1. Agent 1 merges first (no issues)

2. Agent 2 rebases on main:
   ```bash
   git pull origin main
   cd packages/database
   pnpm prisma migrate resolve --rolled-back 20251107100100_add_loyalty_tiers
   pnpm prisma migrate dev  # Recreates with new timestamp
   # Result: 20251107100200_add_loyalty_tiers/
   ```

3. Both migrations now in correct order:
   ```
   migrations/
   ├── 20251107100000_add_user_mfa/
   └── 20251107100200_add_loyalty_tiers/
   ```

### Communication Protocol

When editing shared files (`base.prisma`):

1. **Check CLAUDE.md** for agent coordination notes
2. **Document intent** in `/docs/tasks/IN-PROGRESS.md`
3. **Small changes first**: Add enum values in separate PR
4. **Notify other agents**: Update shared documentation

---

## Common Migration Patterns

### 1. Adding a Table

**Schema Change** (`customer.prisma`):
```prisma
model Customer {
  id         String   @id @default(cuid())
  email      String   @unique
  firstName  String
  lastName   String
  businessId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  deletedAt  DateTime?

  business   Business @relation(fields: [businessId], references: [id])

  @@index([businessId])
  @@index([email])
  @@map("customers")
}
```

**Generated SQL**:
```sql
CREATE TABLE "customers" (
  "id" TEXT NOT NULL,
  "email" TEXT NOT NULL,
  "firstName" TEXT NOT NULL,
  "lastName" TEXT NOT NULL,
  "businessId" TEXT NOT NULL,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updatedAt" TIMESTAMP(3) NOT NULL,
  "deletedAt" TIMESTAMP(3),
  CONSTRAINT "customers_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "customers_businessId_fkey" FOREIGN KEY ("businessId") REFERENCES "businesses"("id")
);

CREATE UNIQUE INDEX "customers_email_key" ON "customers"("email");
CREATE INDEX "customers_businessId_idx" ON "customers"("businessId");
CREATE INDEX "customers_email_idx" ON "customers"("email");
```

### 2. Adding a Column

**Schema Change**:
```prisma
model Customer {
  // ... existing fields
  phoneNumber String?  // ← Add optional field
}
```

**Generated SQL**:
```sql
ALTER TABLE "customers" ADD COLUMN "phoneNumber" TEXT;
```

**Required Field** (with default):
```prisma
model Customer {
  // ... existing fields
  status Status @default(ACTIVE)  // ← Add with default
}
```

**Generated SQL**:
```sql
ALTER TABLE "customers" ADD COLUMN "status" "Status" NOT NULL DEFAULT 'ACTIVE';
```

### 3. Renaming a Column

**Schema Change**:
```prisma
model Customer {
  // Before: firstName
  // After:
  fullName String @map("firstName")  // ← Use @map to preserve column name
}
```

**Then create custom migration**:
```bash
pnpm prisma migrate dev --name rename_firstname_to_fullname --create-only
```

**Edit the generated SQL** to preserve data:
```sql
-- Rename column instead of drop + add
ALTER TABLE "customers" RENAME COLUMN "firstName" TO "fullName";
```

### 4. Adding an Index

**Schema Change**:
```prisma
model Customer {
  email String @unique

  @@index([email, businessId])  // ← Composite index
  @@index([createdAt(sort: Desc)])  // ← Sorted index
}
```

**Generated SQL**:
```sql
CREATE INDEX "customers_email_businessId_idx" ON "customers"("email", "businessId");
CREATE INDEX "customers_createdAt_idx" ON "customers"("createdAt" DESC);
```

### 5. Adding a Relation

**Schema Change**:
```prisma
model Customer {
  id       String   @id
  segments CustomerSegment[]  // ← One-to-many relation
}

model CustomerSegment {
  id         String   @id
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])

  @@index([customerId])
}
```

**Generated SQL**:
```sql
ALTER TABLE "customer_segments" ADD COLUMN "customerId" TEXT NOT NULL;
ALTER TABLE "customer_segments" ADD CONSTRAINT "customer_segments_customerId_fkey"
  FOREIGN KEY ("customerId") REFERENCES "customers"("id");
CREATE INDEX "customer_segments_customerId_idx" ON "customer_segments"("customerId");
```

### 6. Changing Column Type

**Dangerous**: Can cause data loss

**Safe Approach** (expand-contract):
```prisma
// Step 1: Add new column
model Customer {
  pointsOld Int?     // Rename old column
  points    Decimal  // Add new column with different type
}
```

Migration 1:
```sql
ALTER TABLE "customers" RENAME COLUMN "points" TO "pointsOld";
ALTER TABLE "customers" ADD COLUMN "points" DECIMAL(65,30);
```

Then run data migration (see [Data Migrations](#data-migrations)).

Migration 2:
```sql
ALTER TABLE "customers" DROP COLUMN "pointsOld";
```

---

## Zero-Downtime Migrations

For production deployments with zero downtime, use the **expand-contract pattern**.

### Expand-Contract Pattern

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  Expand     │────>│   Migrate    │────>│  Contract   │
│ (Add new)   │     │   (Dual-write)│     │ (Remove old)│
└─────────────┘     └──────────────┘     └─────────────┘
```

### Example: Renaming a Column

**Step 1: Expand** (Add new column, keep old):
```prisma
model Customer {
  name     String?  // Old column (keep)
  fullName String?  // New column (add)
}
```

Migration:
```sql
ALTER TABLE "customers" ADD COLUMN "fullName" TEXT;
```

Deploy: ✅ Old code still works (uses `name`), new code can use `fullName`

**Step 2: Migrate Data** (Copy old → new):
```typescript
// data-migration.ts
await prisma.$executeRaw`
  UPDATE customers
  SET "fullName" = name
  WHERE "fullName" IS NULL;
`;
```

**Step 3: Deploy Code** (Start using `fullName`):
```typescript
// Before
await prisma.customer.create({ data: { name: 'John' } });

// After (dual-write during transition)
await prisma.customer.create({
  data: {
    name: 'John',     // Keep writing to old for backward compat
    fullName: 'John'  // Start writing to new
  }
});
```

**Step 4: Contract** (Remove old column):
```prisma
model Customer {
  fullName String  // Only new column remains
}
```

Migration:
```sql
ALTER TABLE "customers" DROP COLUMN "name";
```

Deploy: ✅ Old code is gone, only new code deployed

### Zero-Downtime Checklist

- [ ] **Never remove columns immediately** - Use expand-contract
- [ ] **Add columns as optional first** - Make required later
- [ ] **Use dual-writes during transition** - Write to both old and new
- [ ] **Deploy in multiple phases** - Separate expand, migrate, contract
- [ ] **Test rollback scenarios** - Ensure old code still works during expand
- [ ] **Monitor after each phase** - Check errors before proceeding
- [ ] **Use feature flags** - Toggle between old and new logic

---

## Multi-Tenant Patterns

NxLoy is multi-tenant with `businessId` on all tenant-scoped tables.

### Adding `businessId` to Existing Table

**Schema Change**:
```prisma
model Customer {
  id         String   @id
  email      String
  businessId String   // ← Add this

  business   Business @relation(fields: [businessId], references: [id])

  @@unique([email, businessId])  // ← Email unique per business
  @@index([businessId])
}
```

**Generated Migration**:
```sql
-- Step 1: Add column as nullable
ALTER TABLE "customers" ADD COLUMN "businessId" TEXT;

-- Step 2: Populate with data (requires custom script)
-- UPDATE customers SET "businessId" = ... WHERE ...;

-- Step 3: Make NOT NULL (requires --create-only)
ALTER TABLE "customers" ALTER COLUMN "businessId" SET NOT NULL;

-- Step 4: Add foreign key
ALTER TABLE "customers" ADD CONSTRAINT "customers_businessId_fkey"
  FOREIGN KEY ("businessId") REFERENCES "businesses"("id");

-- Step 5: Add index
CREATE INDEX "customers_businessId_idx" ON "customers"("businessId");

-- Step 6: Update unique constraint
DROP INDEX "customers_email_key";
CREATE UNIQUE INDEX "customers_email_businessId_key" ON "customers"("email", "businessId");
```

**Safe Multi-Step Approach**:

1. Add `businessId` as optional:
   ```bash
   pnpm prisma migrate dev --name add_businessid_to_customers_optional
   ```

2. Run data migration to populate:
   ```typescript
   // scripts/migrate-businessid.ts
   const customers = await prisma.customer.findMany();
   for (const customer of customers) {
     await prisma.customer.update({
       where: { id: customer.id },
       data: { businessId: getBusinessIdForCustomer(customer) }
     });
   }
   ```

3. Make `businessId` required:
   ```bash
   pnpm prisma migrate dev --name make_businessid_required --create-only
   ```
   Edit migration to:
   ```sql
   ALTER TABLE "customers" ALTER COLUMN "businessId" SET NOT NULL;
   ```

### Row-Level Security (RLS)

**PostgreSQL RLS Example** (add to migration):
```sql
-- Enable RLS on table
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

-- Create policy: Users can only see their business's customers
CREATE POLICY customers_isolation ON customers
  USING ("businessId" = current_setting('app.current_business_id')::text);

-- Create policy: Business admins can manage their customers
CREATE POLICY customers_admin ON customers
  FOR ALL
  USING ("businessId" = current_setting('app.current_business_id')::text);
```

**Application-Level Isolation** (recommended for NxLoy):
```typescript
// middleware/tenant.middleware.ts
export class TenantMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const businessId = extractBusinessId(req);
    req['businessId'] = businessId;
    next();
  }
}

// All queries include businessId filter
await prisma.customer.findMany({
  where: { businessId: req['businessId'] }
});
```

---

## Soft Delete Patterns

NxLoy uses soft deletes with `deletedAt` timestamp.

### Adding Soft Delete to Table

**Schema Change**:
```prisma
model Customer {
  id        String    @id
  email     String
  deletedAt DateTime?  // ← Add this

  @@index([deletedAt])  // ← Index for filtering active records
}
```

**Generated SQL**:
```sql
ALTER TABLE "customers" ADD COLUMN "deletedAt" TIMESTAMP(3);
CREATE INDEX "customers_deletedAt_idx" ON "customers"("deletedAt");
```

### Soft Delete Middleware

**Prisma Middleware** (auto-filter deleted records):
```typescript
// packages/database/src/middleware/soft-delete.ts
import { Prisma } from '@prisma/client';

export function softDeleteMiddleware(): Prisma.Middleware {
  return async (params, next) => {
    if (params.action === 'delete') {
      // Convert delete to update
      params.action = 'update';
      params.args.data = { deletedAt: new Date() };
    }

    if (params.action === 'deleteMany') {
      params.action = 'updateMany';
      params.args.data = { deletedAt: new Date() };
    }

    // Filter out deleted records
    if (params.action === 'findUnique' || params.action === 'findFirst') {
      params.args.where = {
        ...params.args.where,
        deletedAt: null
      };
    }

    if (params.action === 'findMany') {
      if (params.args.where) {
        if (params.args.where.deletedAt === undefined) {
          params.args.where.deletedAt = null;
        }
      } else {
        params.args.where = { deletedAt: null };
      }
    }

    return next(params);
  };
}
```

**Register Middleware**:
```typescript
// packages/database/src/index.ts
import { PrismaClient } from '@prisma/client';
import { softDeleteMiddleware } from './middleware/soft-delete';

export const prisma = new PrismaClient();

prisma.$use(softDeleteMiddleware());

export * from '@prisma/client';
```

### Querying Soft-Deleted Records

```typescript
// Get active customers only (default)
const customers = await prisma.customer.findMany();

// Get deleted customers
const deletedCustomers = await prisma.customer.findMany({
  where: { deletedAt: { not: null } }
});

// Get all customers (including deleted)
const allCustomers = await prisma.$queryRaw`
  SELECT * FROM customers;
`;

// Restore deleted customer
await prisma.customer.update({
  where: { id: customerId },
  data: { deletedAt: null }
});
```

---

## Data Migrations

For complex data transformations, create separate TypeScript scripts.

### Script Structure

```typescript
// packages/database/scripts/migrations/001-migrate-user-names.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('Starting data migration: Split user names...');

  const users = await prisma.user.findMany({
    where: {
      fullName: { not: null },
      firstName: null  // Not yet migrated
    }
  });

  console.log(`Found ${users.length} users to migrate`);

  for (const user of users) {
    const [firstName, ...lastNameParts] = user.fullName.split(' ');
    const lastName = lastNameParts.join(' ');

    await prisma.user.update({
      where: { id: user.id },
      data: { firstName, lastName }
    });

    console.log(`Migrated user ${user.id}: ${user.fullName} → ${firstName} ${lastName}`);
  }

  console.log('Data migration complete!');
}

main()
  .catch((e) => {
    console.error('Migration failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

### Running Data Migrations

```bash
# Development
cd packages/database
pnpm tsx scripts/migrations/001-migrate-user-names.ts

# Production (via package.json script)
cd packages/database
pnpm run data-migrate:001
```

### Data Migration Best Practices

1. **Idempotent**: Can be run multiple times safely
2. **Logged**: Console.log progress for debugging
3. **Batched**: Process large datasets in chunks
4. **Atomic**: Use transactions when possible
5. **Reversible**: Include rollback script if needed
6. **Tested**: Test on copy of production data first

**Batched Example**:
```typescript
const batchSize = 1000;
let skip = 0;

while (true) {
  const users = await prisma.user.findMany({
    where: { firstName: null },
    take: batchSize,
    skip: skip
  });

  if (users.length === 0) break;

  await prisma.$transaction(
    users.map(user =>
      prisma.user.update({
        where: { id: user.id },
        data: migrateUserData(user)
      })
    )
  );

  skip += batchSize;
  console.log(`Processed ${skip} users...`);
}
```

---

## Rollback Strategies

Prisma Migrate **does not have automatic rollbacks**. Manual rollback required.

### Rollback Methods

#### Method 1: Revert and Recreate

1. **Revert schema change**:
   ```bash
   git revert HEAD  # Revert commit with migration
   ```

2. **Mark failed migration as rolled back**:
   ```bash
   pnpm prisma migrate resolve --rolled-back 20251107000001_failed_migration
   ```

3. **Create new migration** to undo changes:
   ```bash
   pnpm prisma migrate dev --name revert_failed_changes
   ```

#### Method 2: Manual SQL Rollback

1. **Write reverse SQL**:
   ```sql
   -- Original migration added column
   -- ALTER TABLE "customers" ADD COLUMN "newField" TEXT;

   -- Rollback SQL
   ALTER TABLE "customers" DROP COLUMN "newField";
   ```

2. **Apply via raw SQL**:
   ```bash
   psql $DATABASE_URL -c "ALTER TABLE customers DROP COLUMN newField;"
   ```

3. **Mark as rolled back**:
   ```bash
   pnpm prisma migrate resolve --rolled-back 20251107000001_migration
   ```

4. **Reset Prisma state**:
   ```bash
   pnpm prisma generate
   ```

#### Method 3: Database Restore (Last Resort)

1. **Restore from backup**:
   ```bash
   pg_restore -d nxloy_production backup.dump
   ```

2. **Mark migrations as applied**:
   ```bash
   pnpm prisma migrate resolve --applied 20251107000001_migration
   ```

### Rollback Best Practices

- **Test migrations in staging first** - Catch issues before production
- **Keep database backups** - Automated backups before deploy
- **Write rollback SQL** - Document reverse operation in migration PR
- **Use expand-contract** - Avoid need for rollbacks entirely
- **Monitor after deploy** - Quick detection = easier rollback

---

## CI/CD Integration

### GitHub Actions Example

```yaml
# .github/workflows/database-migrations.yml
name: Database Migrations

on:
  pull_request:
    paths:
      - 'packages/database/prisma/**'
  push:
    branches: [main]

jobs:
  validate-migrations:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: nxloy_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v3

      - uses: pnpm/action-setup@v2
        with:
          version: 10.14.0

      - uses: actions/setup-node@v3
        with:
          node-version: '22.12.0'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Validate migrations
        working-directory: packages/database
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/nxloy_test
        run: |
          # Apply all migrations
          pnpm prisma migrate deploy

          # Check migration status
          pnpm prisma migrate status

          # Generate Prisma Client
          pnpm prisma generate

          # Run database tests
          pnpm test

  deploy-migrations:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: validate-migrations

    steps:
      - uses: actions/checkout@v3

      - name: Deploy to production
        working-directory: packages/database
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          # Backup database first
          ./scripts/backup-database.sh

          # Apply migrations
          pnpm prisma migrate deploy

          # Verify deployment
          pnpm prisma migrate status
```

### Pre-Deployment Checklist

```bash
# Run locally before pushing migrations

# 1. Validate migration SQL
cat packages/database/prisma/migrations/*/migration.sql

# 2. Test migration on local database
cd packages/database
pnpm prisma migrate reset  # Reset to clean state
pnpm prisma migrate dev    # Apply all migrations

# 3. Test rollback (if applicable)
# Write and test reverse SQL

# 4. Run tests
cd ../..
nx test database

# 5. Check affected projects
nx affected:test
nx affected:build

# 6. Commit migration files
git add packages/database/prisma/
git commit -m "feat(database): add customer loyalty points"
```

---

## Migration Checklist

Use this checklist for every migration:

### Before Creating Migration

- [ ] **Understand the change** - What tables/columns are affected?
- [ ] **Check for breaking changes** - Will this break existing code?
- [ ] **Plan rollback strategy** - How to undo if needed?
- [ ] **Consider multi-tenant impact** - Does every business need this?
- [ ] **Estimate data volume** - Large tables need special handling
- [ ] **Check domain boundaries** - Is this change in the right schema file?

### Creating Migration

- [ ] **Edit Prisma schema** - Make changes in correct domain file
- [ ] **Run `prisma migrate dev --name xxx`** - Use descriptive name
- [ ] **Review generated SQL** - Verify it's correct and safe
- [ ] **Add custom SQL if needed** - Edit migration file for data changes
- [ ] **Test migration locally** - Run `prisma migrate reset && prisma migrate dev`
- [ ] **Generate Prisma Client** - Auto-generated, verify types

### Before Committing

- [ ] **Run affected tests** - `nx affected:test`
- [ ] **Run linter** - `nx affected:lint`
- [ ] **Check type errors** - `nx run-many --target=typecheck --all`
- [ ] **Update seed data** - If schema changes affect seeds
- [ ] **Document in PR** - Explain migration purpose and risks
- [ ] **Add rollback SQL** - Document reverse operation

### Before Production Deploy

- [ ] **Test in staging** - Apply migration to staging database
- [ ] **Backup production database** - Automated backup before deploy
- [ ] **Check zero-downtime** - Use expand-contract if needed
- [ ] **Monitor during deploy** - Watch logs for errors
- [ ] **Verify after deploy** - Run health checks
- [ ] **Document in change log** - Update `changes/{branch}.md`

### After Production Deploy

- [ ] **Monitor error rates** - Check for increased errors
- [ ] **Verify data integrity** - Spot-check migrated data
- [ ] **Update documentation** - API docs, schema docs
- [ ] **Notify team** - Announce migration completion
- [ ] **Archive migration notes** - Move to `/docs/database/migrations/`

---

## Getting Help

### Common Issues

**Issue**: Migration fails with "relation already exists"
**Solution**:
```bash
pnpm prisma migrate resolve --applied 20251107000001_migration
```

**Issue**: Prisma Client out of sync
**Solution**:
```bash
pnpm prisma generate
```

**Issue**: Migration stuck in "pending" state
**Solution**:
```bash
pnpm prisma migrate resolve --rolled-back 20251107000001_migration
pnpm prisma migrate dev
```

**Issue**: Can't roll back migration
**Solution**: See [Rollback Strategies](#rollback-strategies)

### Resources

- **Prisma Docs**: https://www.prisma.io/docs/concepts/components/prisma-migrate
- **NxLoy Architecture**: `/docs/ARCHITECTURE.md`
- **Migration Examples**: `/docs/database/MIGRATION-EXAMPLES.md`
- **Team Chat**: Slack #nxloy-database

---

**Last Updated**: 2025-11-07
**Maintained By**: NxPloy
**Next Review**: 2025-12-07
